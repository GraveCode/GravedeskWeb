// Generated by CoffeeScript 1.6.3
(function() {
  var ViewModel, closedIterator, getTickets, openIterator, status, statusCSS, updateDates;

  ViewModel = {
    user: {},
    open: ko.observableArray(),
    closed: ko.observableArray()
  };

  status = ["Accepted", "In progress", "Needs response"];

  statusCSS = ["secondary", "success", "alert"];

  openIterator = function(ticket, callback) {
    ticket.friendlyDate = ko.observable(moment(+ticket.modified).fromNow() || null);
    ticket.friendlyStatus = status[+ticket.status] || null;
    ticket.friendlyStatusCSS = statusCSS[+ticket.status] || null;
    ticket.gotoMessages = function() {
      return window.location = "/messages/?id=" + ticket._id;
    };
    return callback(null, ticket);
  };

  closedIterator = function(ticket, callback) {
    ticket.friendlyDate = moment(+ticket.modified).format('Do MMMM YYYY') || null;
    ticket.gotoMessages = function() {
      return window.location = "/messages/?id=" + ticket._id;
    };
    return callback(null, ticket);
  };

  getTickets = function() {
    return socket.emit('getMyTickets', ViewModel.user.emails[0].value, function(err, open, closed) {
      if (err) {
        return console.log(err);
      } else {
        async.map(open, openIterator, function(err, results) {
          return ViewModel.open(results);
        });
        async.map(closed, closedIterator, function(err, results) {
          return ViewModel.closed(results);
        });
        return ko.applyBindings(ViewModel);
      }
    });
  };

  updateDates = function() {
    var iterator;
    iterator = function(item, callback) {
      var date;
      date = moment(+item.modified).fromNow() || null;
      item.friendlyDate(date);
      return callback(null);
    };
    return async.each(ViewModel.open(), iterator, function(err) {
      if (err) {
        return console.log(err);
      }
    });
  };

  $(document).ready(function() {
    $.ajax({
      url: "/node/getuser"
    }).done(function(userdata) {
      if (!userdata) {
        return window.location.replace("/node/google");
      } else {
        ViewModel.user = userdata;
        getTickets();
        return window.setInterval(function() {
          return updateDates();
        }, 1000 * 30);
      }
    });
    return socket.on('ticketAdded', function(id, ticket) {
      var i;
      i = ticket.recipients.indexOf(ViewModel.user.emails[0].value);
      if (i >= 0) {
        return openIterator(ticket, function(err, newTicket) {
          return ViewModel.open.unshift(newTicket);
        });
      }
    });
  });

}).call(this);
